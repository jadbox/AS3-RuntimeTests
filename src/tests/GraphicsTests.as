package tests {		import flash.display.Shape;	import flash.display.Graphics;	import flash.display.GraphicsPathCommand;	import com.gskinner.performance.TestSuite;	import com.gskinner.performance.MethodTest;		public class GraphicsTests extends TestSuite {			// Constants:			// Public Properties:		// the number of loops to run in every test:		public var loops:uint = 100000;			// Protected Properties:		// a shape instance to use in every test:		protected var shape:Shape = new Shape();		// used for tests that draw a bunch of smaller shapes:		protected var shortLoops:uint = 100;		protected var shortIterations:uint = loops/shortLoops;			// Initialization:		public function GraphicsTests() {			name = "GraphicsTests";			description = "Compares different methods for using the graphics API to draw a shape with "+loops+" lines, or draw "+shortIterations+" 'short' shapes with "+shortLoops+" lines.";			tareTest = new MethodTest(tare);			iterations = 4;			tests = [				new MethodTest(fullPath, null, "fullPath", 0, 1, "shape.graphics.lineTo"),				new MethodTest(withGraphics, null, "withGraphics", 0, 1, "with(shape.graphics)"),				new MethodTest(reference, null, "reference", 0, 1, "g.lineTo"),				new MethodTest(shortReference, null, "shortReference", 0, 1, "g.lineTo *short"),				new MethodTest(drawPath, null, "drawPath", 0, 1, "drawPath"),				new MethodTest(drawPathShort, null, "drawPathShort", 0, 1, "drawPath *short")			];		}			// Public getter / setters:			// Public Methods:			// Protected Methods:		// tare method that will be run to calculate the base time required to run the loop		// and ancillary graphics operations so it can be subtracted from the other test results.		protected function tare():void {			shape.graphics.lineStyle(0,0,1);			for (var i:uint=0; i<loops; i++) {				// nothing.			}			shape.graphics.clear();		}				// note that these tests do not test the time required to render the graphic, only to		// generate the vector data. You could use testRender to test the render time.		protected function fullPath():void {			shape.graphics.lineStyle(0,0,1);			for (var i:uint=0; i<loops; i++) {				shape.graphics.lineTo(i%100*3,i%200);			}			shape.graphics.clear();		}				protected function withGraphics():void {			shape.graphics.lineStyle(0,0,1);			with (shape.graphics) {				for (var i:uint=0; i<loops; i++) {					lineTo(i%100*3,i%200);				}			}			shape.graphics.clear();		}				protected function reference():void {			shape.graphics.lineStyle(0,0,1);			var g:Graphics = shape.graphics;			for (var i:uint=0; i<loops; i++) {				g.lineTo(i%100*3,i%200);			}			shape.graphics.clear();		}						protected function shortReference():void {			for (var j:uint=0; j<shortIterations; j++) {				shape.graphics.lineStyle(0,0,1);				var g:Graphics = shape.graphics;				for (var i:uint=0; i<shortLoops; i++) {					g.lineTo(i%100*3,i%200);				}				shape.graphics.clear();			}		}				protected function drawPath():void {			shape.graphics.lineStyle(0,0,1);			var cmds:Vector.<int> = new Vector.<int>(loops,true);			var data:Vector.<Number> = new Vector.<Number>(loops*2,true);			var cmd:int = GraphicsPathCommand.LINE_TO;			for (var i:uint=0; i<loops; i++) {				cmds[i] = cmd;				data[i*2] = i%100*3;				data[i*2+1] = i%200;			}			shape.graphics.drawPath(cmds,data);			shape.graphics.clear();		}				protected function drawPathShort():void {			for (var j:uint=0; j<shortIterations; j++) {				shape.graphics.lineStyle(0,0,1);				var cmds:Vector.<int> = new Vector.<int>(shortLoops,true);				var data:Vector.<Number> = new Vector.<Number>(shortLoops*2,true);				var cmd:int = GraphicsPathCommand.LINE_TO;				for (var i:uint=0; i<shortLoops; i++) {					cmds[i] = cmd;					data[i*2] = i%100*3;					data[i*2+1] = i%200;				}				shape.graphics.drawPath(cmds,data);				shape.graphics.clear();			}		}			}	}