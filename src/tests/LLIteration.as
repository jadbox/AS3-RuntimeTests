// GDS: this seems to execute very slowly versus the time reported. My guess is the GC is having to work hard.package tests {		import tests.assets.LLNode;	import tests.assets.LLNodeVO;	import tests.assets.LLNodeFinal;	import tests.assets.LLNodeFinalVO;	import flash.geom.Point;	import com.gskinner.performance.TestSuite;	import com.gskinner.performance.MethodTest;		public class LLIteration extends TestSuite {			// Constants:			// Public Properties:		// the number of elements in each collection:		public var loops:uint = 1000000;			// Protected Properties:				// set up some variables used in the test:		protected var _vector:Vector.<Point>;		protected var _vectorFixed:Vector.<Point>;		protected var _internalNode:Node;		protected var _node:LLNode;		protected var _nodeVO:LLNodeVO;		protected var _nodeFinal:LLNodeFinal;		protected var _nodeFinalVO:LLNodeFinalVO;			// Initialization:		public function LLIteration() {			name = "LLIteration";			description = "Comparing iteration speed of linked lists & Vectors. "+loops+" loops.";			tareTest = new MethodTest(tare);			initFunction = init;			iterations = 4;			tests = [				new MethodTest(vector, null, "vector", 0, 1, "vector"),				new MethodTest(vectorFixed, null, "vectorFixed", 0, 1, "vector fixed"),				new MethodTest(internalNode, null, "internalNode", 0, 1, "internal node"),				new MethodTest(node, null, "node", 0, 1, "node"),				new MethodTest(nodeVO, null, "nodeVO", 0, 1, "VO node"),				new MethodTest(nodeFinal, null, "nodeFinal", 0, 1, "node Final"),				new MethodTest(nodeFinalVO, null, "nodeFinalVO", 0, 1, "VO node Final")			];		}			// Public getter / setters:			// Public Methods:			// Protected Methods:		protected function init():void {			// vector:			var list:Vector.<Point> = new Vector.<Point>();			for (var i:uint=0; i<loops; i++) {				list[i] = new Point(i,i*2);			}			_vector = list;						//vectorFixed:			list = new Vector.<Point>(loops);			for (i=0; i<loops; i++) {				list[i] = new Point(i,i*2);			}			_vectorFixed = list;						// internalNode:			_internalNode = constructLL(Node) as Node;						// node:			_node = constructLL(LLNode) as LLNode;						// nodeVO:			_nodeVO = constructLLVO(LLNodeVO) as LLNodeVO;						// nodeFinal:			_nodeFinal = constructLL(LLNodeFinal) as LLNodeFinal;						// nodeFinalVO:			_nodeFinalVO = constructLLVO(LLNodeFinalVO) as LLNodeFinalVO;		}				protected function constructLL(nodeClass:Class):Object {			var o:Object = new nodeClass(null,null,new Point(0,0));			var ret:Object = o;			for (var i:uint=0; i<loops; i++) {				var oo:Object = o;				o = new nodeClass(null,o,new Point(i,i*2));				oo.next = o;			}			return ret;		}				protected function constructLLVO(nodeClass:Class):Object {			var o:Object = new nodeClass(null,null,0,0);			var ret:Object = o;			for (var i:uint=0; i<loops; i++) {				var oo:Object = o;				o = new nodeClass(null,o,i,i*2);				oo.next = o;			}			return ret;		}					// tare method that will be run to calculate the base time required to run the loop		// so it can be subtracted from the other test results.		public function tare():void {		}				public function vector():void {			var l:uint = _vector.length;			for (var i:uint=0; i<l; i++) {				var pt:Point = _vector[i];				var z:Number = pt.x+pt.y;			}		}				public function vectorFixed():void {			for (var i:uint=0; i<loops; i++) {				var pt:Point = _vectorFixed[i];				var z:Number = pt.x+pt.y;			}		}				public function internalNode():void {			var o:Node = _internalNode;			do {				var pt:Point = o.value;				var z:Number = pt.x+pt.y;			} while (o = o.next);		}				public function node():void {			var o:LLNode = _node;			do {				var pt:Point = o.value;				var z:Number = pt.x+pt.y;			} while (o = o.next);		}				public function nodeFinal():void {			var o:LLNodeFinal = _nodeFinal;			do {				var pt:Point = o.value;				var z:Number = pt.x+pt.y;			} while (o = o.next);		}				public function nodeVO():void {			var o:LLNodeVO = _nodeVO;			do {				var z:Number = o.x+o.y;			} while (o = o.next);		}				public function nodeFinalVO():void {			var o:LLNodeFinalVO = _nodeFinalVO;			do {				var z:Number = o.x+o.y;			} while (o = o.next);		}				}	}import flash.geom.Point;class Node {		public var value:Point;	public var next:Node;	public var prev:Node;		public function Node(next:Node,prev:Node,value:Point) {		this.next = next;		this.prev = prev;		this.value = value;	}	}